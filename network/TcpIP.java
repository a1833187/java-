package qrxedu.network;

/**
 * @author qiu
 * @version 1.8.0
 */
@SuppressWarnings("all")
public class TcpIP {
    /*
    网络带宽是啥?
    TCP/IP五层协议栈
    1.应用层
    应用层协议：设计一种请求和响应相匹配的组织形式。
    常见的应用层协议模板：
        1.xml：由标签组成:<标签名>内容<标签名>,可读性比较强,但是标签名信息太多了,引入了太多的辅助信息
        xml现在主要用来写一些配置文件
        2.json:当下最流行的一种应用层协议设计格式,
        格式:{键:值,键:值...}  要求键必须是字符串类型(单双引号都可),值不要求.可读性更强,且占用的带宽比较少
        但json中仍然添加了一部分冗余信息(key)

        3.protobuffer:是一种二进制格式的数据,在protobuffer中没有了key而是通过一种特殊的二进制形式来明确对应数据的意义
        同时protobuffer还有对应的IDL文件用来描述特殊的二进制形式的含义,IDL文件只用来辅助,并不真正的传输.
        protubuffer的可读性不高(对调试不友好),但效率高.
        最知名的应用层协议:HTTP!!!
    2.传输层
    最常见的协议是TCP和UDP
    TCP的特点:1.有连接 2.可靠 3.面向字节流 4.全双工  UDP的特点:1.无连接 2.不可靠 3.面向数据报 4.全双工

    UDP的数据报的格式:UDP报头(4*2个字节) + UDP数据载荷(完整的应用层数据)
    UDP报头:源端口,目的端口,UDP报文长度(字节),校验和:检验应用层数据是否正确,网络上传递的数据的本质是光信号,电信号.这些数据在传输的过程中如果收到外界
    因素的影响可能导致数据被修改
    因为报文长度是2个字节,导致UDP数据的长度在65535之内,进而导致UDP不能传一个大的数据,除非在应用层将数据进行分包(但这个步骤太麻烦了:丢包\顺序不对)
    有效的解决方法是用TCP,TCP不限制数据的大小.

    TCP的关键机制体现在可靠运输上.
    一.确认应答:保证可靠运输的核心机制.    接收方收到信息之后给发送方返回一个应答报文(ACK),表示已经收到
    在确认应答机制中,当发送方发送多条信息时,由于网络的复杂性可能导致发送方接收到接收方的应答报文的顺序和发送的信息不匹配,解决这种混淆问题的办法
    就是编号,给发送的信息进行编号.在TCP报头中有32位序号和32位确认序号.
    上述是基于接收方正常接收到发送方的信息,但接收方也可能因为异常导致没有接收到发送方的信息或者接收方发送的ack发送方没有接收到.
    针对这个问题,引出另外一个机制:超时重传:
    三.连接管理(高频面试题):1.如何建立连接:三次握手 SYN-->ACK,SYN-->ACK    SYN:为1时表示同步数据报  ACK:为1时表示应答报文
                    三次握手的作用:1.投石问路,检测双方的网络是否能够满足可靠传输的条件
                                 2.让双方能够协商一些重要的信息
                         2.如何断开连接:四次挥手:FIN -->ACK --> FIN -->ACK  FIN:结束报文段
                                       中间两次不能合并的原因:两次发送的时机不一样.ACK是操作系统内核进行的,FIN是用户态(如close())进行的.
                                       当然中间两次有时候也能合并(当ACK和FIN发生的时间差比较小时就可以合并(属于一种优化))
    四.滑动窗口:由于确认应答机制的存在导致下一份发送的前提是 前一份的ACK必须接收到,这导致了发送效率变低.
    滑动窗口意味着每次发送多份报文,当某个报文发送完毕 就向后滑动,让下一份报文发送.
    滑动窗口解决数据丢包的问题:1.ACK丢了:这个可以不作处理.因为只要接受到 后续确认序号的ACK意味着前面的报文都已经接收到.
                           2.数据报丢了:当某个序号区间的报文丢失后,后续ACK的确认序号都是丢失之前的确认序号,但不影响后续报文的发送,当丢失的报文
                           发送了之后,ACK的确认序号直接滑到滑动窗口的最后一个报文的确认序号.
    滑动窗口越大,传输效率越快,但需要考虑接收方的接收速度.
    五.流量控制:是滑动窗口的延伸.直接使用接收方缓冲区的剩余空间大小来衡量当前的处理能力.如果剩余空间比较大,就可以让发送方发送的更快一点.
    当接收方的缓冲区填满后,发送方不会继续发送数据报,而会定期的发送一个窗口探测来获取接收方缓存区的剩余大小(通过ACK来反馈)
    六.拥塞控制:滑动窗口的延伸,限制滑动窗口的速率,衡量的是发送方到接收方整个链路
    (发送方和接收方往往不是直连的两个设备,中间可能要经过多个交换机和路由器)之间的拥堵情况(处理能力).
    七.延时应答:相当于流量控制的延伸,在流量控制的基础上让窗口的大小尽可能的大.
    八.捎带应答:相当于延时应答的延伸,也就是让ACK(内核进行)等待和应用程序数据的发送同步进行.
    九.面向字节流===>粘包问题(是针对一切具有面向字节流的机制):当接收方发送多个数据报给接收方时,接收方分用这些数据包然后将数据解析到缓冲区,
    这时接收方的应用程序在读取包内容时如果不作处理就无法区分每个数据报中的数据的长度是多少(TCP的报头没有数据文的长度这个属性),就容易把多个数据报中的内容一下子读完.
    解决方法就是约定在每个包的末尾加上";"或者是应用程序在读取包内容时能够读取到每个包的长度.
    十.TCP的异常处理:
        1.进程终止:在进程毫无防备的情况下直接关闭这个进程(任务管理器直接手动结束进程)
        TCP连接是通过socket来建立的,socket本质上是操作系统上的一个文件,该文件的启动纪录存储在OS中PCB中的文件描述符表中,当结束一个进程的
        时候,OS中的PCB就没了,文件描述符表中也没了,因此socket也就自动关闭了(和手动socket.close()效果等同)
        2.机器关机:正常关机,会让OS直接关闭所有进程,等同于"进程终止"
        3.机器断电/网络断开::异常关机(直接干电源!),操作系统来不及作任何处理.这时分两种情况:
               1.接收方异常关闭:这时发送方发送的数据不会接收到接收方的ACK,A进入超时重传,几次重传失败后发送方就会断开连接,进而释放之前与接收方
               建立连接的相关信息.
               2.发送方异常关闭:这时接收方一直接受不到发送方发送的数据,等待一段时间后接收方会时不时地向接收方中放出一段探测报文以触发发送方的
               ACK,如果发送方不予回答,接收方也会断开与发送方的连接.


    TCP vs UDP
    1.对可靠性有一定要求用TCP(日常开发一般都是基于TCP)
    2.对可靠性要求不高,对效率要求高,用UDP(机房内部的主机之间通信)

    基于UDP如何实现可靠运输?
    本质上就是UDP在应用层上  复刻TCP在内核中的那一套.

    3.网络层
    4.数据链路层
    5.物理层
     */
}
