package qrxedu.sort;

/**
 * @author qiu
 * @version 1.8.0
 */
public class Summary {
    /*
    稳定的排序算法：直接插入排序、冒泡排序、归并排序
    不稳定的排序算法：选择排序、快速排序、堆排序、希尔排序
    时间复杂度为O(n log n):快速排序、堆排序、归并排序
    空间复杂度从小到大依次为：O(n2)的排序和堆排序--O(1)、快速排序---O(log n)-O(n)、归并排序---O(n)

    速度：快速排序   空间复杂度要求更高：堆排序    稳定性要求更高：归并排序
    直接插入排序适用与数据量比较小且整体顺序趋于有序的序列
    对于快速排序的优化是基于基准值而言的：对于基准值的选择：1.边上选 2.随机选择 3.三数取中法
    3可以有效规避数据量过大造成栈溢出的问题，实质上就是让每次递归基准值的左右序列分布的更均匀一点
    还可以通过在partition中将与基准值相同的元素移到基准值跟前来进一步优化
    也可以考虑在递归过程中，如果数据量比较小且整体比较有序可以利用直接插入排序来优化快排
    对于快速排序的非递归算法则是用栈来存储每次递归的左右下标，然后一次取出右下标和左下标进行partition，类似于二叉树的层次遍历


    归并排序适用于数据量过大超过内存的外部排序，可以对数据量分别存储到不同的文件，对不同的文件中的数据先
    进行内部排序，然后通过文件指针对文件进行归并排序
    对于归并排序的非递归算法则是通过两两归并进行实现。先是以1为每组元素个数，然后一次是2、4、8...直到等于数组的长度
    通过设置left、mid、mid+1、right的值，调用merge函数。

     */
}
