package qrxedu.network;

/**
 * @author qiu
 * @version 1.8.0
 */
@SuppressWarnings("all")
public class TcpIP {
    /*
    网络带宽是啥?
    TCP/IP五层协议栈
    1.应用层
    应用层协议：设计一种请求和响应相匹配的组织形式。
    常见的应用层协议模板：
        1.xml：由标签组成:<标签名>内容<标签名>,可读性比较强,但是标签名信息太多了,引入了太多的辅助信息
        xml现在主要用来写一些配置文件
        2.json:当下最流行的一种应用层协议设计格式,
        格式:{键:值,键:值...}  要求键必须是字符串类型(单双引号都可),值不要求.可读性更强,且占用的带宽比较少
        但json中仍然添加了一部分冗余信息(key)

        3.protobuffer:是一种二进制格式的数据,在protobuffer中没有了key而是通过一种特殊的二进制形式来明确对应数据的意义
        同时protobuffer还有对应的IDL文件用来描述特殊的二进制形式的含义,IDL文件只用来辅助,并不真正的传输.
        protubuffer的可读性不高(对调试不友好),但效率高.
        最知名的应用层协议:HTTP!!!
    其他应用层协议:DNS(域名解析):IP地址不好记,DNS通过一串英文单词来表示某个IP地址,这一串英文单词叫做域名.
    最早的域名解析系统就是一个host文件,记录了多个IP地址和其对应的域名
    后来就变成了域名解析服务器
    2.传输层
    最常见的协议是TCP和UDP
    TCP的特点:1.有连接 2.可靠 3.面向字节流 4.全双工  UDP的特点:1.无连接 2.不可靠 3.面向数据报 4.全双工

    UDP的数据报的格式:UDP报头(4*2个字节) + UDP数据载荷(完整的应用层数据)
    UDP报头:源端口,目的端口,UDP报文长度(字节),校验和:检验应用层数据是否正确,网络上传递的数据的本质是光信号,电信号.这些数据在传输的过程中如果收到外界
    因素的影响可能导致数据被修改
    因为报文长度是2个字节,导致UDP数据的长度在65535之内,进而导致UDP不能传一个大的数据,除非在应用层将数据进行分包(但这个步骤太麻烦了:丢包\顺序不对)
    有效的解决方法是用TCP,TCP不限制数据的大小.

    TCP的关键机制体现在可靠运输上.
    一.确认应答:保证可靠运输的核心机制.    接收方收到信息之后给发送方返回一个应答报文(ACK),表示已经收到
    在确认应答机制中,当发送方发送多条信息时,由于网络的复杂性可能导致发送方接收到接收方的应答报文的顺序和发送的信息不匹配,解决这种混淆问题的办法
    就是编号,给发送的信息进行编号.在TCP报头中有32位序号和32位确认序号.
    上述是基于接收方正常接收到发送方的信息,但接收方也可能因为异常导致没有接收到发送方的信息或者接收方发送的ack发送方没有接收到.
    针对这个问题,引出另外一个机制:超时重传:
    三.连接管理(高频面试题):1.如何建立连接:三次握手 SYN-->ACK,SYN-->ACK    SYN:为1时表示同步数据报  ACK:为1时表示应答报文
                    三次握手的作用:1.投石问路,检测双方的网络是否能够满足可靠传输的条件
                                 2.让双方能够协商一些重要的信息
                         2.如何断开连接:四次挥手:FIN -->ACK --> FIN -->ACK  FIN:结束报文段
                                       中间两次不能合并的原因:两次发送的时机不一样.ACK是操作系统内核进行的,FIN是用户态(如close())进行的.
                                       当然中间两次有时候也能合并(当ACK和FIN发生的时间差比较小时就可以合并(属于一种优化))
    四.滑动窗口:由于确认应答机制的存在导致下一份发送的前提是 前一份的ACK必须接收到,这导致了发送效率变低.
    滑动窗口意味着每次发送多份报文,当某个报文发送完毕 就向后滑动,让下一份报文发送.
    滑动窗口解决数据丢包的问题:1.ACK丢了:这个可以不作处理.因为只要接受到 后续确认序号的ACK意味着前面的报文都已经接收到.
                           2.数据报丢了:当某个序号区间的报文丢失后,后续ACK的确认序号都是丢失之前的确认序号,但不影响后续报文的发送,当丢失的报文
                           发送了之后,ACK的确认序号直接滑到滑动窗口的最后一个报文的确认序号.
    滑动窗口越大,传输效率越快,但需要考虑接收方的接收速度.
    五.流量控制:是滑动窗口的延伸.直接使用接收方缓冲区的剩余空间大小来衡量当前的处理能力.如果剩余空间比较大,就可以让发送方发送的更快一点.
    当接收方的缓冲区填满后,发送方不会继续发送数据报,而会定期的发送一个窗口探测来获取接收方缓存区的剩余大小(通过ACK来反馈)
    六.拥塞控制:滑动窗口的延伸,限制滑动窗口的速率,衡量的是发送方到接收方整个链路
    (发送方和接收方往往不是直连的两个设备,中间可能要经过多个交换机和路由器)之间的拥堵情况(处理能力).
    七.延时应答:相当于流量控制的延伸,在流量控制的基础上让窗口的大小尽可能的大.
    八.捎带应答:相当于延时应答的延伸,也就是让ACK(内核进行)等待和应用程序数据的发送同步进行.
    九.面向字节流===>粘包问题(是针对一切具有面向字节流的机制):当接收方发送多个数据报给接收方时,接收方分用这些数据包然后将数据解析到缓冲区,
    这时接收方的应用程序在读取包内容时如果不作处理就无法区分每个数据报中的数据的长度是多少(TCP的报头没有数据文的长度这个属性),就容易把多个数据报中的内容一下子读完.
    解决方法就是约定在每个包的末尾加上";"或者是应用程序在读取包内容时能够读取到每个包的长度.
    十.TCP的异常处理:
        1.进程终止:在进程毫无防备的情况下直接关闭这个进程(任务管理器直接手动结束进程)
        TCP连接是通过socket来建立的,socket本质上是操作系统上的一个文件,该文件的启动纪录存储在OS中PCB中的文件描述符表中,当结束一个进程的
        时候,OS中的PCB就没了,文件描述符表中也没了,因此socket也就自动关闭了(和手动socket.close()效果等同)
        2.机器关机:正常关机,会让OS直接关闭所有进程,等同于"进程终止"
        3.机器断电/网络断开::异常关机(直接干电源!),操作系统来不及作任何处理.这时分两种情况:
               1.接收方异常关闭:这时发送方发送的数据不会接收到接收方的ACK,A进入超时重传,几次重传失败后发送方就会断开连接,进而释放之前与接收方
               建立连接的相关信息.
               2.发送方异常关闭:这时接收方一直接受不到发送方发送的数据,等待一段时间后接收方会时不时地向接收方中放出一段探测报文以触发发送方的
               ACK,如果发送方不予回答,接收方也会断开与发送方的连接.


    TCP vs UDP
    1.对可靠性有一定要求用TCP(日常开发一般都是基于TCP)
    2.对可靠性要求不高,对效率要求高,用UDP(机房内部的主机之间通信)

    基于UDP如何实现可靠运输?(博客上自己总结一次)
    本质上就是UDP在应用层上  复刻TCP在内核中的那一套.

    3.网络层
      IP协议:
      1.地址管理
      2.路由选择
      IP地址:分为网络号+主机号,由32位整数通过点分十进制来表示.同一个局域网内的两个主机的网络号相同,主机号不同;
      连接两个局域网之间的两个路由器的网络号不同.
      通过"子网掩码"来表示哪些位表示网络号,哪些位表示主机号,子网掩码由连续的1和连续的0组成,左边的1所占的
      位就是网络号,右边的0所占的位就是主机号.
      在一般家里由于设备数不会超过255,子网掩码的地址一般为:255.255.255.0

      特殊的IP地址
      1.如果IP的主机号为 全0,该IP表示网络号(局域网里的一个正常的设备的主机号不能全0)
      2.如果IP的主机号为 全1,该IP就表示"广播地址",往这个广播地址上发的消息,整个局域网都能收到
      3.IP地址以127开头的 表示"环回IP"(即表示主机自己)
      4.IP地址是10开头,192.168开头,172,16-172.31开头,表示该IP地址是一个局域网内部的IP(内网IP)
      除此之外,剩下的IP称为外网IP(直接在广域网上的IP)
      外网IP是一定唯一的,每个外网IP都会对应到唯一的一个设备.
      内网IP只是在当前局域网中唯一,也就是说不同的设备如果处在不同的局域网中,则这些设备的内网IP地址可能相同
      原因是因为IPV4提供的32位整数表示的范围已经不适用于全球的所有设备量了.让每个设备都具有唯一的IP地址对于IPV4
      已经不现实了.
      如何解决这个问题?
        1.动态分配IP地址:一个设备只有在连网的情况下才会分配IP地址,不联网的情况下不分配IP地址.
        2.NAT机制:让多台设备共用一个外网IP,把网络分成了局域网和广域网.
        局域网1中的设备在访问局域网2中的设备时会经过运营商路由器,将内网IP改为外网IP,
        即一个局域网中的所有设备在访问其他局域网中的设备时,会通过运营商路由器将不同的内网IP改为统一的运营商IP
        同时如果一个局域网中的不同的设备的端口号也相等(概率很小) 运营商路由器也会对设备的端口号进行相应的调整.
        针对同一个局域网中的不同设备向同一个其他局域网内的应用发送请求时,其对应的运营商IP地址相同,这时候
        区分两台设备的就是这两台设备的端口号.
        用局域网1中的设备去访问局域网2中的设备不能用内网IP(因为有可能导致重复),要让局域网1中的设备和
        局域网2中的设备同时访问一个外网IP,通过外网IP实现网络通信.
        NAT机制的极限就是端口号(64K)
        3.IPV6:相较于IPV4的32位整数的IP地址,IPV6提供了128位整数的IP地址.从根本上解决了IP地址不够用问题.
        但由于IPV4和IPV6不兼容.导致现在更多的是利用IPV4+NAT


      路由选择:规划路径.两个设备之间找出一条能够完成传输的通道,如果有多条通道,则选择更好的.
      路由器中存储有一个路由表,路由表中纪录了一些网段信息(网络号)以及每个网络号对应的网路接口(网络接口
      就是对应路由器里的网络端口),如果传来的IP地址路由表中有记录,则可以直接通过该记录向后传输,如果没有记录则会
      选取一个大致的方向(下一跳)
      存在,则
    4.数据链路层
    主要的协议:"以太网".平时插的网线叫做"以太网线".,"以太网"规定了数据链路层和物理层的协议.
    以太网数据帧:目的地址和原地址都是6个字节(IPV4是4个字节),称为"mac地址",mac地址做到了每个设备(每个网卡)是
    唯一的.
    IP:用来表示一次传输过程中的起点和终点.
    mac:用来表示传输过程中任意两个相邻节点之间的地址

    MTU:一个以太网数据帧能够承载的数据范围(取决于硬件设备.)
    CRC:帧尾基于CRC算法(数据冗余算法)的校验和
    ARP协议:路由器在转发数据时,首先接收到的是一个目的IP,路由器需要根据这个IP决定封装后的以太网数据帧
   `的目的mac地址是什么,ARP协议建立了关于IP->mac的映射关系.这个ARP协议可能直接在硬盘中存储.
   当设备启动的时候会向局域网中发送广播报文,局域网中的每个设备会将自身的IP和mac发送给设备.设备根据回应建立
   ARP协议.
    5.物理层
     */
}
